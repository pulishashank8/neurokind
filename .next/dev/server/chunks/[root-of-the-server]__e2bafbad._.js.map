{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 106, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\n\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\n\nexport const prisma =\n  globalForPrisma.prisma ||\n  new PrismaClient({\n    errorFormat: \"pretty\",\n  });\n\nif (process.env.NODE_ENV !== \"production\") globalForPrisma.prisma = prisma;\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM;AAEC,MAAM,SACX,gBAAgB,MAAM,IACtB,IAAI,sMAAY,CAAC;IACf,aAAa;AACf;AAEF,wCAA2C,gBAAgB,MAAM,GAAG"}},
    {"offset": {"line": 121, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/src/lib/validators.ts"],"sourcesContent":["import { z } from \"zod\";\n\nexport const LoginSchema = z.object({\n  email: z.string().email(\"Invalid email address\"),\n  password: z.string().min(6, \"Password must be at least 6 characters\"),\n});\n\nexport const RegisterSchema = z.object({\n  email: z.string().email(\"Invalid email address\"),\n  password: z\n    .string()\n    .min(8, \"Password must be at least 8 characters\")\n    .regex(/[A-Z]/, \"Password must contain at least one uppercase letter\")\n    .regex(/[a-z]/, \"Password must contain at least one lowercase letter\")\n    .regex(/[0-9]/, \"Password must contain at least one number\")\n    .regex(/[^a-zA-Z0-9]/, \"Password must contain at least one symbol\"),\n  confirmPassword: z.string(),\n  username: z\n    .string()\n    .min(3, \"Username must be at least 3 characters\")\n    .max(20, \"Username must be at most 20 characters\")\n    .regex(/^[a-zA-Z0-9_-]+$/, \"Username can only contain letters, numbers, underscores, and hyphens\"),\n  displayName: z.string().min(1, \"Display name is required\").max(100),\n});\n\nexport const RegisterSchemaWithConfirm = RegisterSchema.refine(\n  (data) => data.password === data.confirmPassword,\n  {\n    message: \"Passwords don't match\",\n    path: [\"confirmPassword\"],\n  }\n);\n\nexport const ProfileUpdateSchema = z.object({\n  username: z\n    .string()\n    .min(3, \"Username must be at least 3 characters\")\n    .max(20, \"Username must be at most 20 characters\")\n    .regex(/^[a-zA-Z0-9_-]+$/, \"Username can only contain letters, numbers, underscores, and hyphens\")\n    .optional(),\n  displayName: z.string().min(1, \"Display name is required\").max(100).optional(),\n  bio: z.string().max(500, \"Bio must be at most 500 characters\").optional(),\n  location: z.string().max(100, \"Location must be at most 100 characters\").optional(),\n  avatarUrl: z.string().url(\"Invalid URL\").optional(),\n});\n\nexport type LoginInput = z.infer<typeof LoginSchema>;\nexport type RegisterInput = z.infer<typeof RegisterSchemaWithConfirm>;\nexport type ProfileUpdateInput = z.infer<typeof ProfileUpdateSchema>;\n"],"names":[],"mappings":";;;;;;;;;;AAAA;;AAEO,MAAM,cAAc,yKAAC,CAAC,MAAM,CAAC;IAClC,OAAO,yKAAC,CAAC,MAAM,GAAG,KAAK,CAAC;IACxB,UAAU,yKAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;AAC9B;AAEO,MAAM,iBAAiB,yKAAC,CAAC,MAAM,CAAC;IACrC,OAAO,yKAAC,CAAC,MAAM,GAAG,KAAK,CAAC;IACxB,UAAU,yKAAC,CACR,MAAM,GACN,GAAG,CAAC,GAAG,0CACP,KAAK,CAAC,SAAS,uDACf,KAAK,CAAC,SAAS,uDACf,KAAK,CAAC,SAAS,6CACf,KAAK,CAAC,gBAAgB;IACzB,iBAAiB,yKAAC,CAAC,MAAM;IACzB,UAAU,yKAAC,CACR,MAAM,GACN,GAAG,CAAC,GAAG,0CACP,GAAG,CAAC,IAAI,0CACR,KAAK,CAAC,oBAAoB;IAC7B,aAAa,yKAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG,4BAA4B,GAAG,CAAC;AACjE;AAEO,MAAM,4BAA4B,eAAe,MAAM,CAC5D,CAAC,OAAS,KAAK,QAAQ,KAAK,KAAK,eAAe,EAChD;IACE,SAAS;IACT,MAAM;QAAC;KAAkB;AAC3B;AAGK,MAAM,sBAAsB,yKAAC,CAAC,MAAM,CAAC;IAC1C,UAAU,yKAAC,CACR,MAAM,GACN,GAAG,CAAC,GAAG,0CACP,GAAG,CAAC,IAAI,0CACR,KAAK,CAAC,oBAAoB,wEAC1B,QAAQ;IACX,aAAa,yKAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG,4BAA4B,GAAG,CAAC,KAAK,QAAQ;IAC5E,KAAK,yKAAC,CAAC,MAAM,GAAG,GAAG,CAAC,KAAK,sCAAsC,QAAQ;IACvE,UAAU,yKAAC,CAAC,MAAM,GAAG,GAAG,CAAC,KAAK,2CAA2C,QAAQ;IACjF,WAAW,yKAAC,CAAC,MAAM,GAAG,GAAG,CAAC,eAAe,QAAQ;AACnD"}},
    {"offset": {"line": 161, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/src/lib/env.ts"],"sourcesContent":["import { z } from \"zod\";\n\n/**\n * Environment validation schema with Zod\n * - Required: DATABASE_URL, NEXTAUTH_SECRET, NEXTAUTH_URL\n * - Optional: REDIS_URL, API keys\n * Fails fast at startup if required vars missing\n */\n\nconst envSchema = z.object({\n  // Required\n  DATABASE_URL: z.string().url().describe(\"PostgreSQL database URL\"),\n  NEXTAUTH_SECRET: z.string().min(32).describe(\"NextAuth secret (min 32 chars)\"),\n  NEXTAUTH_URL: z.string().url().describe(\"NextAuth callback URL\"),\n\n  // Optional (with sensible defaults)\n  REDIS_URL: z\n    .string()\n    .url()\n    .optional()\n    .describe(\"Redis URL for caching and rate limiting\"),\n  OPENAI_API_KEY: z\n    .string()\n    .optional()\n    .describe(\"OpenAI API key for AI features\"),\n  GROQ_API_KEY: z\n    .string()\n    .optional()\n    .describe(\"Groq API key for AI chat features\"),\n  GOOGLE_PLACES_API_KEY: z\n    .string()\n    .optional()\n    .describe(\"Google Places API key for location features\"),\n  GOOGLE_CLIENT_ID: z\n    .string()\n    .optional()\n    .describe(\"Google OAuth client ID\"),\n  GOOGLE_CLIENT_SECRET: z\n    .string()\n    .optional()\n    .describe(\"Google OAuth client secret\"),\n  NEXT_PUBLIC_APP_URL: z\n    .string()\n    .url()\n    .default(\"http://localhost:3000\")\n    .describe(\"Public app URL\"),\n\n  // Node env\n  NODE_ENV: z\n    .enum([\"development\", \"production\", \"test\"])\n    .default(\"development\"),\n});\n\nexport type Env = z.infer<typeof envSchema>;\n\nlet validatedEnv: Env | null = null;\n\n/**\n * Get validated environment variables\n * Validates on first call, then returns cached result\n */\nexport function getEnv(): Env {\n  if (validatedEnv) return validatedEnv;\n\n  try {\n    validatedEnv = envSchema.parse(process.env);\n    return validatedEnv;\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      const missingVars = error.errors\n        .filter((e) => e.code === \"invalid_type\" || e.code === \"too_small\")\n        .map((e) => `${e.path.join(\".\")}: ${e.message}`)\n        .join(\"\\n  \");\n\n      console.error(\n        \"❌ Environment validation failed:\\n  \" + missingVars + \"\\n\"\n      );\n      throw new Error(\n        \"Missing required environment variables. See details above.\"\n      );\n    }\n    throw error;\n  }\n}\n\n/**\n * Validate optional variables gracefully\n * Returns undefined if not set, doesn't crash\n */\nexport function getOptionalEnv<T extends keyof Env>(key: T): Env[T] | undefined {\n  const env = getEnv();\n  return env[key] as Env[T] | undefined;\n}\n\n/**\n * Check if Redis is available (safe to use in features)\n */\nexport function isRedisAvailable(): boolean {\n  try {\n    const env = getEnv();\n    return !!env.REDIS_URL;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Check if AI features are enabled (OpenAI or Groq)\n */\nexport function isAIEnabled(): boolean {\n  try {\n    const env = getEnv();\n    return !!(env.OPENAI_API_KEY || env.GROQ_API_KEY);\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Check if Groq AI is configured\n */\nexport function isGroqEnabled(): boolean {\n  try {\n    return !!getEnv().GROQ_API_KEY;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Check if Google Places API is configured\n */\nexport function isGooglePlacesEnabled(): boolean {\n  try {\n    return !!getEnv().GOOGLE_PLACES_API_KEY;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Check if Google OAuth is configured\n */\nexport function isGoogleOAuthEnabled(): boolean {\n  try {\n    const env = getEnv();\n    return !!(env.GOOGLE_CLIENT_ID && env.GOOGLE_CLIENT_SECRET);\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Check if we're in production\n */\nexport function isProduction(): boolean {\n  return process.env.NODE_ENV === \"production\";\n}\n\n/**\n * SECURITY: Validate that server-only secrets are never exposed\n * This function should be called in server-side code only\n * Returns true if all secret keys are properly secured\n */\nexport function validateSecretSecurity(): { secure: boolean; issues: string[] } {\n  const issues: string[] = [];\n\n  // Check that sensitive env vars are NOT prefixed with NEXT_PUBLIC_\n  const sensitiveKeys = [\n    'DATABASE_URL',\n    'NEXTAUTH_SECRET',\n    'OPENAI_API_KEY',\n    'GROQ_API_KEY',\n    'GOOGLE_PLACES_API_KEY',\n    'GOOGLE_CLIENT_SECRET',\n    'REDIS_URL'\n  ];\n\n  for (const key of sensitiveKeys) {\n    const publicKey = `NEXT_PUBLIC_${key}`;\n    if (process.env[publicKey]) {\n      issues.push(`SECURITY RISK: ${publicKey} should NOT be prefixed with NEXT_PUBLIC_. This exposes secrets to the client!`);\n    }\n  }\n\n  return {\n    secure: issues.length === 0,\n    issues\n  };\n}\n\n// Validate env on module load (fail fast on server-side only)\nif (typeof window === \"undefined\" && typeof process !== \"undefined\") {\n  try {\n    getEnv();\n\n    // Security check: Ensure secrets are not exposed\n    const securityCheck = validateSecretSecurity();\n    if (!securityCheck.secure) {\n      console.error(\"⚠️ SECURITY ISSUES DETECTED:\");\n      securityCheck.issues.forEach(issue => console.error(`  - ${issue}`));\n    }\n  } catch (error) {\n    // Only log; don't call process.exit in modules that might run in Edge Runtime\n    console.error(\"Failed to load environment variables:\", error);\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 310, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/src/lib/logger.ts"],"sourcesContent":["import pino from 'pino';\nimport { isProduction } from './env';\n\n/**\n * Sensitive field names that should never be logged\n * These patterns are checked recursively in all nested objects\n */\nconst SENSITIVE_FIELDS = [\n  'password',\n  'token',\n  'secret',\n  'apiKey',\n  'api_key',\n  'authorization',\n  'cookie',\n  'session',\n  'accessToken',\n  'refreshToken',\n  'privateKey',\n  'private_key',\n];\n\n/**\n * Recursively redact sensitive fields from objects\n */\nfunction redactSensitive(obj: any): any {\n  if (obj === null || obj === undefined) return obj;\n  \n  if (typeof obj !== 'object') return obj;\n  \n  if (Array.isArray(obj)) {\n    return obj.map(item => redactSensitive(item));\n  }\n  \n  const redacted: any = {};\n  for (const [key, value] of Object.entries(obj)) {\n    const lowerKey = key.toLowerCase();\n    const isSensitive = SENSITIVE_FIELDS.some(field => \n      lowerKey.includes(field.toLowerCase())\n    );\n    \n    if (isSensitive) {\n      redacted[key] = '[REDACTED]';\n    } else if (typeof value === 'object') {\n      redacted[key] = redactSensitive(value);\n    } else {\n      redacted[key] = value;\n    }\n  }\n  \n  return redacted;\n}\n\n/**\n * Production logger configuration (JSON output)\n */\nconst productionLogger = pino({\n  level: process.env.LOG_LEVEL || 'info',\n  formatters: {\n    level: (label: string) => {\n      return { level: label };\n    },\n  },\n  serializers: {\n    req: (req: any) => redactSensitive({\n      method: req.method,\n      url: req.url,\n      headers: req.headers,\n    }),\n    res: (res: any) => ({\n      statusCode: res.statusCode,\n    }),\n    err: pino.stdSerializers.err,\n  },\n  redact: {\n    paths: SENSITIVE_FIELDS,\n    remove: true,\n  },\n});\n\n/**\n * Development logger configuration (pretty output)\n * Only use pino-pretty in local development (not on Vercel)\n */\nconst developmentLogger = process.env.VERCEL \n  ? productionLogger  // Use production logger on Vercel even in preview/development\n  : pino({\n      level: process.env.LOG_LEVEL || 'debug',\n      transport: {\n        target: 'pino-pretty',\n        options: {\n          colorize: true,\n          translateTime: 'HH:MM:ss.l',\n          ignore: 'pid,hostname',\n          singleLine: false,\n          messageFormat: '{levelLabel} - {msg}',\n        },\n      },\n      serializers: {\n        req: (req: any) => redactSensitive({\n          method: req.method,\n          url: req.url,\n          headers: req.headers,\n        }),\n        res: (res: any) => ({\n          statusCode: res.statusCode,\n        }),\n        err: pino.stdSerializers.err,\n      },\n      redact: {\n        paths: SENSITIVE_FIELDS,\n        remove: true,\n      },\n    });\n\n/**\n * Main logger instance\n * Automatically switches between production and development modes\n */\nexport const logger = isProduction() || process.env.VERCEL ? productionLogger : developmentLogger;\n\n/**\n * Create a child logger with additional context\n * Useful for adding requestId or other contextual data\n */\nexport function createLogger(bindings: Record<string, any>) {\n  return logger.child(redactSensitive(bindings));\n}\n\n/**\n * Log levels for convenience\n */\nexport const logLevels = {\n  debug: 'debug',\n  info: 'info',\n  warn: 'warn',\n  error: 'error',\n} as const;\n\nexport type LogLevel = typeof logLevels[keyof typeof logLevels];\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;;;AAEA;;;CAGC,GACD,MAAM,mBAAmB;IACvB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD;AAED;;CAEC,GACD,SAAS,gBAAgB,GAAQ;IAC/B,IAAI,QAAQ,QAAQ,QAAQ,WAAW,OAAO;IAE9C,IAAI,OAAO,QAAQ,UAAU,OAAO;IAEpC,IAAI,MAAM,OAAO,CAAC,MAAM;QACtB,OAAO,IAAI,GAAG,CAAC,CAAA,OAAQ,gBAAgB;IACzC;IAEA,MAAM,WAAgB,CAAC;IACvB,KAAK,MAAM,CAAC,KAAK,MAAM,IAAI,OAAO,OAAO,CAAC,KAAM;QAC9C,MAAM,WAAW,IAAI,WAAW;QAChC,MAAM,cAAc,iBAAiB,IAAI,CAAC,CAAA,QACxC,SAAS,QAAQ,CAAC,MAAM,WAAW;QAGrC,IAAI,aAAa;YACf,QAAQ,CAAC,IAAI,GAAG;QAClB,OAAO,IAAI,OAAO,UAAU,UAAU;YACpC,QAAQ,CAAC,IAAI,GAAG,gBAAgB;QAClC,OAAO;YACL,QAAQ,CAAC,IAAI,GAAG;QAClB;IACF;IAEA,OAAO;AACT;AAEA;;CAEC,GACD,MAAM,mBAAmB,IAAA,uJAAI,EAAC;IAC5B,OAAO,QAAQ,GAAG,CAAC,SAAS,IAAI;IAChC,YAAY;QACV,OAAO,CAAC;YACN,OAAO;gBAAE,OAAO;YAAM;QACxB;IACF;IACA,aAAa;QACX,KAAK,CAAC,MAAa,gBAAgB;gBACjC,QAAQ,IAAI,MAAM;gBAClB,KAAK,IAAI,GAAG;gBACZ,SAAS,IAAI,OAAO;YACtB;QACA,KAAK,CAAC,MAAa,CAAC;gBAClB,YAAY,IAAI,UAAU;YAC5B,CAAC;QACD,KAAK,uJAAI,CAAC,cAAc,CAAC,GAAG;IAC9B;IACA,QAAQ;QACN,OAAO;QACP,QAAQ;IACV;AACF;AAEA;;;CAGC,GACD,MAAM,oBAAoB,QAAQ,GAAG,CAAC,MAAM,GACxC,iBAAkB,8DAA8D;GAChF,IAAA,uJAAI,EAAC;IACH,OAAO,QAAQ,GAAG,CAAC,SAAS,IAAI;IAChC,WAAW;QACT,QAAQ;QACR,SAAS;YACP,UAAU;YACV,eAAe;YACf,QAAQ;YACR,YAAY;YACZ,eAAe;QACjB;IACF;IACA,aAAa;QACX,KAAK,CAAC,MAAa,gBAAgB;gBACjC,QAAQ,IAAI,MAAM;gBAClB,KAAK,IAAI,GAAG;gBACZ,SAAS,IAAI,OAAO;YACtB;QACA,KAAK,CAAC,MAAa,CAAC;gBAClB,YAAY,IAAI,UAAU;YAC5B,CAAC;QACD,KAAK,uJAAI,CAAC,cAAc,CAAC,GAAG;IAC9B;IACA,QAAQ;QACN,OAAO;QACP,QAAQ;IACV;AACF;AAMG,MAAM,SAAS,IAAA,mIAAY,OAAM,QAAQ,GAAG,CAAC,MAAM,GAAG,mBAAmB;AAMzE,SAAS,aAAa,QAA6B;IACxD,OAAO,OAAO,KAAK,CAAC,gBAAgB;AACtC;AAKO,MAAM,YAAY;IACvB,OAAO;IACP,MAAM;IACN,MAAM;IACN,OAAO;AACT"}},
    {"offset": {"line": 434, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/src/lib/rateLimit.ts"],"sourcesContent":["import { getEnv, isRedisAvailable } from \"./env\";\nimport { NextResponse } from \"next/server\";\n\n/**\n * Redis-based rate limiter with in-memory fallback for development\n * Uses token bucket algorithm: allows N requests per window\n *\n * Usage:\n *   const limiter = new RateLimiter(\"register\", 3, 3600); // 3 per hour\n *   const canProceed = await limiter.checkLimit(ipAddress);\n *   if (!canProceed) {\n *     const retryAfter = await limiter.getRetryAfter(ipAddress);\n *     return res.status(429).json({ error: \"Rate limit exceeded\", retryAfterSeconds: retryAfter });\n *   }\n */\n\ninterface RateLimitEntry {\n  tokens: number;\n  lastRefill: number;\n}\n\nlet redisClient: any = null;\nlet inMemoryStore = new Map<string, RateLimitEntry>();\n\n/**\n * Initialize Redis client lazily\n */\nasync function getRedisClient() {\n  if (redisClient) return redisClient;\n\n  if (!isRedisAvailable()) {\n    return null;\n  }\n\n  try {\n    // Lazy load Redis (using ioredis)\n    const { Redis } = await import(\"ioredis\");\n    const client = new Redis(getEnv().REDIS_URL!, {\n      lazyConnect: true,\n      maxRetriesPerRequest: 0,\n      enableOfflineQueue: false,\n    });\n\n    client.on(\"error\", (err: any) => {\n      console.warn(\"Redis connection error, falling back to in-memory:\", err.message);\n      redisClient = null;\n    });\n\n    redisClient = client;\n    console.log(\"✓ Redis connected for rate limiting\");\n    return client;\n  } catch (error) {\n    console.warn(\n      \"Failed to connect to Redis, using in-memory rate limiting:\",\n      error instanceof Error ? error.message : error\n    );\n    return null;\n  }\n}\n\nexport class RateLimiter {\n  readonly name: string;\n  readonly maxTokens: number;\n  readonly windowSeconds: number;\n\n  constructor(\n    name: string,\n    maxTokens: number,\n    windowSeconds: number = 60\n  ) {\n    this.name = name;\n    this.maxTokens = maxTokens;\n    this.windowSeconds = windowSeconds;\n  }\n\n  /**\n   * Check if request is allowed\n   * Returns true if within limit, false if exceeded\n   */\n  async checkLimit(identifier: string): Promise<boolean> {\n    const key = `ratelimit:${this.name}:${identifier}`;\n    const redis = await getRedisClient();\n\n    if (redis) {\n      return this.checkLimitRedis(redis, key);\n    } else {\n      return this.checkLimitMemory(key);\n    }\n  }\n\n  /**\n   * Get seconds until next request allowed\n   */\n  async getRetryAfter(identifier: string): Promise<number> {\n    const key = `ratelimit:${this.name}:${identifier}`;\n    const redis = await getRedisClient();\n\n    if (redis) {\n      const ttl = await redis.ttl(key);\n      return Math.max(1, ttl);\n    } else {\n      const entry = inMemoryStore.get(key);\n      if (!entry) return 0;\n\n      const elapsed = (Date.now() - entry.lastRefill) / 1000;\n      const remaining = this.windowSeconds - elapsed;\n      return Math.max(1, Math.ceil(remaining));\n    }\n  }\n\n  /**\n   * Redis-based rate limiting\n   */\n  private async checkLimitRedis(redis: any, key: string): Promise<boolean> {\n    try {\n      const current = await redis.incr(key);\n\n      if (current === 1) {\n        // First request in window, set expiry\n        await redis.expire(key, this.windowSeconds);\n      }\n\n      return current <= this.maxTokens;\n    } catch (error) {\n      console.error(\"Redis rate limit check failed:\", error);\n      // Fail open - allow request if Redis fails\n      return true;\n    }\n  }\n\n  /**\n   * In-memory rate limiting (development fallback)\n   */\n  private checkLimitMemory(key: string): boolean {\n    const now = Date.now();\n    let entry = inMemoryStore.get(key);\n\n    if (!entry) {\n      inMemoryStore.set(key, {\n        tokens: 1,\n        lastRefill: now,\n      });\n      return true;\n    }\n\n    // Check if window expired\n    const elapsed = (now - entry.lastRefill) / 1000;\n    if (elapsed >= this.windowSeconds) {\n      // Reset window\n      entry = { tokens: 1, lastRefill: now };\n      inMemoryStore.set(key, entry);\n      return true;\n    }\n\n    // Still within window\n    if (entry.tokens < this.maxTokens) {\n      entry.tokens++;\n      inMemoryStore.set(key, entry);\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Reset limit for identifier (for testing)\n   */\n  async reset(identifier: string): Promise<void> {\n    const key = `ratelimit:${this.name}:${identifier}`;\n    const redis = await getRedisClient();\n\n    if (redis) {\n      await redis.del(key);\n    } else {\n      inMemoryStore.delete(key);\n    }\n  }\n}\n\n/**\n * Pre-configured rate limiters for common endpoints\n */\nexport const RATE_LIMITERS = {\n  register: new RateLimiter(\"register\", 5, 3600), // 5/hour per IP\n  login: new RateLimiter(\"login\", 10, 60), // 10/min per IP\n  createPost: new RateLimiter(\"createPost\", 5, 60), // 5/min per user\n  createComment: new RateLimiter(\"createComment\", 10, 60), // 10/min per user\n  vote: new RateLimiter(\"vote\", 60, 60), // 60/min per user\n  report: new RateLimiter(\"report\", 5, 60), // 5/min per user\n  aiChat: new RateLimiter(\"aiChat\", 5, 60), // 5/min per user\n  readComments: new RateLimiter(\"readComments\", 100, 60), // 100/min per IP\n  readPost: new RateLimiter(\"readPost\", 200, 60), // 200/min per IP\n  updateProfile: new RateLimiter(\"updateProfile\", 10, 60), // 10/min per user\n  connectionRequest: new RateLimiter(\"connectionRequest\", 10, 60), // 10/min per user\n  userSearch: new RateLimiter(\"userSearch\", 30, 60), // 30/min per user\n  userProfile: new RateLimiter(\"userProfile\", 60, 60), // 60/min per IP\n  forgotPassword: new RateLimiter(\"forgotPassword\", 3, 300), // 3 per 5 min per email\n  forgotPasswordDaily: new RateLimiter(\"forgotPasswordDaily\", 5, 86400), // 5/day per email\n};\n\n/**\n * Extract IP from request (works behind proxies)\n */\nexport function getClientIp(request: Request): string {\n  const forwarded = request.headers.get(\"x-forwarded-for\");\n  const ip = forwarded ? forwarded.split(\",\")[0] : request.headers.get(\"x-real-ip\");\n  return ip || \"unknown\";\n}\n\n/**\n * Check rate limit and return response if exceeded\n */\nexport async function checkRateLimit(\n  limiter: RateLimiter,\n  identifier: string\n): Promise<{ allowed: boolean; retryAfterSeconds?: number }> {\n  const allowed = await limiter.checkLimit(identifier);\n\n  if (!allowed) {\n    const retryAfterSeconds = await limiter.getRetryAfter(identifier);\n    return { allowed: false, retryAfterSeconds };\n  }\n\n  return { allowed: true };\n}\n\n/**\n * Create rate limit error response\n */\nexport function rateLimitResponse(retryAfterSeconds: number) {\n  return NextResponse.json(\n    {\n      error: \"Rate limit exceeded\",\n      retryAfterSeconds,\n    },\n    {\n      status: 429,\n      headers: {\n        \"Retry-After\": String(retryAfterSeconds),\n      },\n    }\n  );\n}\n\n/**\n * Clear rate limit for a specific identifier (useful for development/testing)\n */\nexport async function clearRateLimit(limiterName: string, identifier: string): Promise<void> {\n  const key = `ratelimit:${limiterName}:${identifier}`;\n  const redis = await getRedisClient();\n\n  if (redis) {\n    await redis.del(key);\n  } else {\n    inMemoryStore.delete(key);\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 636, "column": 0}, "map": {"version":3,"sources":["file:///home/runner/workspace/src/app/api/auth/%5B...nextauth%5D/route.ts"],"sourcesContent":["import NextAuth, { type NextAuthOptions } from \"next-auth\";\nimport CredentialsProvider from \"next-auth/providers/credentials\";\nimport GoogleProvider from \"next-auth/providers/google\";\nimport { prisma } from \"@/lib/prisma\";\nimport { LoginSchema } from \"@/lib/validators\";\nimport bcryptjs from \"bcryptjs\";\nimport { logger } from \"@/lib/logger\";\nimport { RATE_LIMITERS } from \"@/lib/rateLimit\";\n\nexport const authOptions: NextAuthOptions = {\n  // No adapter needed when using JWT strategy\n  providers: [\n    // Credentials provider for email/password login\n    CredentialsProvider({\n      name: \"Credentials\",\n      credentials: {\n        email: { label: \"Email\", type: \"email\" },\n        password: { label: \"Password\", type: \"password\" },\n      },\n      async authorize(credentials, req) {\n        try {\n          logger.info({ email: credentials?.email?.substring(0, 3) + '***' }, 'Login attempt');\n\n          if (!credentials?.email || !credentials?.password) {\n            logger.warn('Missing credentials');\n            return null;\n          }\n\n          // Validate input\n          const parsed = LoginSchema.safeParse({\n            email: credentials.email,\n            password: credentials.password,\n          });\n\n          if (!parsed.success) {\n            logger.warn({ errors: parsed.error.errors }, 'Login validation failed');\n            return null;\n          }\n\n          // Check login rate limit (10 attempts per minute per email)\n          const canLogin = await RATE_LIMITERS.login.checkLimit(parsed.data.email.toLowerCase());\n          if (!canLogin) {\n            logger.warn({ email: parsed.data.email.substring(0, 3) + '***' }, 'Login rate limit exceeded');\n            throw new Error(\"TooManyAttempts\");\n          }\n\n          try {\n            // Find user by email\n            const user = await prisma.user.findUnique({\n              where: { email: parsed.data.email },\n              include: { userRoles: true, profile: true },\n            });\n\n            if (!user) {\n              logger.warn({ email: parsed.data.email.substring(0, 3) + '***' }, 'User not found');\n              return null;\n            }\n\n            // Check password\n            const passwordMatch = await bcryptjs.compare(\n              parsed.data.password,\n              user.hashedPassword || \"\"\n            );\n\n            if (!passwordMatch) {\n              logger.warn({ userId: user.id }, 'Password mismatch');\n              return null;\n            }\n\n            // Check email verification (skip in development mode)\n            if (!user.emailVerified && process.env.NODE_ENV === 'production') {\n              logger.warn({ userId: user.id }, 'User not verified');\n              throw new Error(\"EmailNotVerified\");\n            }\n\n            // Update lastLoginAt\n            await prisma.user.update({\n              where: { id: user.id },\n              data: { lastLoginAt: new Date() },\n            });\n\n            logger.info({ userId: user.id, username: user.profile?.username }, 'Login successful');\n            return {\n              id: user.id,\n              email: user.email,\n              name: user.profile?.displayName || user.profile?.username || user.email,\n              username: user.profile?.username,\n              roles: user.userRoles.map((ur: any) => ur.role),\n            };\n          } catch (err) {\n            logger.error({ error: err }, 'Login authorization failed');\n            // Fallback: allow dev login without DB if env flag is set (non-production only)\n            if (\n              process.env.NODE_ENV !== \"production\" &&\n              process.env.ALLOW_DEV_LOGIN_WITHOUT_DB === \"true\"\n            ) {\n              const devAccounts: Record<string, { password: string; roles: string[] }> = {\n                \"admin@neurokid.local\": { password: \"admin123\", roles: [\"ADMIN\"] },\n                \"parent@neurokid.local\": { password: \"parent123\", roles: [\"PARENT\"] },\n              };\n              const acct = devAccounts[parsed.data.email];\n              if (acct && acct.password === parsed.data.password) {\n                return {\n                  id: parsed.data.email,\n                  email: parsed.data.email,\n                  name: parsed.data.email,\n                  roles: acct.roles,\n                } as any;\n              }\n            }\n            return null;\n          }\n        } catch (outerErr: any) {\n          // Re-throw rate limit errors to surface them properly\n          if (outerErr?.message === \"TooManyAttempts\") {\n            throw new Error(\"TooManyAttempts\");\n          }\n          logger.error({ error: outerErr }, 'Login outer error');\n          return null;\n        }\n      },\n    }),\n\n    // Google OAuth provider (optional, only if env vars are set)\n    ...(process.env.GOOGLE_CLIENT_ID && process.env.GOOGLE_CLIENT_SECRET\n      ? [\n        GoogleProvider({\n          clientId: process.env.GOOGLE_CLIENT_ID,\n          clientSecret: process.env.GOOGLE_CLIENT_SECRET,\n          allowDangerousEmailAccountLinking: true,\n        }),\n      ]\n      : []),\n  ],\n\n  session: {\n    strategy: \"jwt\",\n    maxAge: 30 * 24 * 60 * 60, // 30 days\n  },\n\n  jwt: {\n    maxAge: 30 * 24 * 60 * 60, // 30 days\n  },\n\n  pages: {\n    signIn: \"/login\",\n    error: \"/error\",\n  },\n\n  callbacks: {\n    async signIn({ user, account }) {\n      // For Google OAuth: create user WITHOUT auto-generating profile (requires onboarding)\n      if (account?.provider === \"google\" && user.email) {\n        try {\n          let existingUser = await prisma.user.findUnique({\n            where: { email: user.email },\n            include: { profile: true, userRoles: true },\n          });\n\n          // Create user if doesn't exist (without profile - will complete in onboarding)\n          if (!existingUser) {\n            existingUser = await prisma.user.create({\n              data: {\n                email: user.email,\n                lastLoginAt: new Date(),\n                emailVerified: true,\n                emailVerifiedAt: new Date(),\n                userRoles: {\n                  create: {\n                    role: \"PARENT\",\n                  },\n                },\n              },\n              include: { profile: true, userRoles: true },\n            });\n\n            // Store user ID for JWT\n            user.id = existingUser.id;\n          } else {\n            // Update last login\n            await prisma.user.update({\n              where: { id: existingUser.id },\n              data: { lastLoginAt: new Date() },\n            });\n\n            // Ensure user has PARENT role\n            if (existingUser.userRoles.length === 0) {\n              await prisma.userRole.create({\n                data: {\n                  userId: existingUser.id,\n                  role: \"PARENT\",\n                },\n              });\n            }\n\n            // Store user ID for JWT\n            user.id = existingUser.id;\n          }\n        } catch (err: any) {\n          console.error(\"Error creating/updating Google user:\", err);\n          const errorCode = err?.code ? `DB_ERR_${err.code}` : \"DB_UNKNOWN_ERROR\";\n          const errorMessage = err?.message ? encodeURIComponent(err.message.substring(0, 100)) : \"UnknownError\";\n          return `/error?error=${errorCode}_${errorMessage}`;\n        }\n      }\n      return true;\n    },\n\n    async jwt({ token, user }) {\n      if (user) {\n        token.id = user.id;\n        token.username = (user as any).username;\n        token.roles = (user as any).roles || [];\n      }\n\n      // Refresh user data including username on every token update\n      if (token.id) {\n        try {\n          const userData = await prisma.user.findUnique({\n            where: { id: token.id as string },\n            include: { userRoles: true, profile: true },\n          });\n          if (userData) {\n            token.roles = userData.userRoles.map((ur: any) => ur.role);\n            token.name = userData.profile?.displayName || userData.profile?.username || userData.email;\n            token.username = userData.profile?.username;\n            token.profileComplete = !!userData.profile?.username && !!userData.profile?.displayName;\n          } else {\n            (token as any).disabled = true;\n            delete token.id;\n            token.roles = [];\n            token.profileComplete = false;\n          }\n        } catch {\n          // If DB unavailable, keep existing data (dev fallback)\n        }\n      }\n\n      return token;\n    },\n\n    async session({ session, token }) {\n      if ((token as any).disabled) {\n        // Return an empty session instead of null\n        return { expires: session.expires, user: undefined } as any;\n      }\n      if (session.user) {\n        (session.user as any).id = token.id as string;\n        (session.user as any).username = token.username as string;\n        (session.user as any).roles = token.roles as string[];\n        (session.user as any).profileComplete = token.profileComplete as boolean;\n        // Ensure session.user.name is set to displayName/username\n        session.user.name = token.name as string;\n      }\n      return session;\n    },\n\n    async redirect({ url, baseUrl }) {\n      // Only redirect to allowed origins\n      if (url.startsWith(\"/\")) return `${baseUrl}${url}`;\n      else if (new URL(url).origin === baseUrl) return url;\n      return baseUrl;\n    },\n  },\n};\n\nconst handler = NextAuth(authOptions);\nexport { handler as GET, handler as POST };\n"],"names":[],"mappings":"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"}}]
}